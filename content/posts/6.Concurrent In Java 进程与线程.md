+++  
title = "Concurrent In Java  | 进程与线程"  
subtitle = ""  
date = 2024-06-13  
description = "简要介绍进程和线程、并行与并发的相关知识"  
short = true  
math = false  
header_img = ""  
tags=["Concurrent"]  
series = ["Concurrent"]  
toc = true  
+++  
## 进程与线程  
### 进程  
程序由指令和数据组成，指令要运行，数据要读写，就必须将指令加载到 CPU，数据加载到内存，同样地，在指令运行过程中可能还会用到磁盘，网络等设备  

进程是用来加载指令，管理内存，管理 IO 的，当一个程序被运行，代码从磁盘加载到内存，就开启了一个进程  
  
我们可以将进程看作是程序的一个实例  
### 线程  
一个进程可以分为多个线程  
一个线程就是一个指令流，将指令流中的一条条指令以一种顺序交给 CPU 执行，可以理解为一个程序同时需要做多件事  
  
Java 中，线程是最小的调度单位，进程是最小的资源分配单位  
在 Windows 中，进程是不活动的，只是作为线程的容器  
### 对比  
进程是相互独立的，线程存在于进程内，是进程的子集  
进程有供线程共享的资源，如内存空间  
进程间通信较为复杂：  
‌‌‌‌　　同一台计算机的进程通信称为 IPC Inter-process communication  
‌‌‌‌　　不同计算机之间的进程通信，需要通过网络  

线程通信较为简单，因为它们共享进程内存，比如可以多个线程访问一个共享变量  
线程更轻量，上下文切换成本比进程上下文切换成本低  
### 线程状态  
#### OS 角度  
初始状态：语言层面创建线程，未与 OS 线程关联  
就绪状态：已经与 OS 线程关联，可由 CPU 调度执行  
运行状态：获取到了 CPU 时间片  
阻塞状态：阻塞被唤醒，进入可运行状态，如果不被唤醒，调度器就不会考虑调度它们  
终止状态：线程执行完毕，生命周期结束  
#### Java API 角度  
根据 `Thread.State` 枚举，分为六种状态  
New：线程刚被创建，还没有调用`start()`方法  
RUNNABLE：当调用了`start()`方法之后，这个状态包括了 OS 层面的“就绪状态”，“运行状态”，“阻塞状态”（比如由 BIO 导致的阻塞，对于 Java 这一层来说是透明的，Java 会认为是可运行的）  
BLOCKED，WAITING，TIMED_WAITING：都是 Java 层面对阻塞状态的的细分  
TERMINATED：当前线程运行结束  
### 查看进程线程的方法  
#### Windows  
任务管理器查看进程和线程，可以结束进程  
`tasklist`查看线程  
`taskkill`杀死线程  
#### Linux  
`ps -fe`查看所有进程  
`ps -fT -p <PID>`查看某个进程的所有线程  
`kill`杀死进程  
`top -H -p <PID>`查看某个进程的所有线程  
#### Java  
`jps`查看所有 Java 进程  
`jstack<PID>`查看某个 Java 进程的所有线程状态  
`jconsole`来查看某个 Java 进程中线程的运行情况  
## 并行与并发  
单核 CPU 下，线程实际上是串行执行的，但是由于 CPU 在线程之间的切换非常快，对于人类来说是同时运行的，**微观串行，宏观并行**  
一般将**线程轮流使用 CPU** 的做法称为并发 concurrent  
  
*tips： Windows 下的时间片最小约为15ms*  
  
多核 CPU 下，每个核心都可以调度运行线程，这个时候线程是可以并行的  
  
>Rob Pike 对并发和并行的简要描述：  
>- 并发 concurrent 是同一时间应对多件事情的能力  
>- 并行 parallel 是同一时间动手做多件事情的能力  
### 异步调用  
对于调用方来说：  
‌‌‌‌　　需要等待结果返回，才能继续运行是同步  
‌‌‌‌　　不需要等待结果返回，就能继续运行是异步  
  
多线程可以让方法的执行变为异步，举个例子，Tomcat 的异步 servlet，让用户线程处理耗时比较长的操作，避免阻塞 Tomcat 的工作线程  
### 提高效率  
单核 CPU 下，多线程不能实际提高程序运行效率只是为了能够在不同的任务之间切换，不同线程轮流使用 CPU，防止部分线程饥饿  
  
多核 CPU 可以并行跑多个线程，但并不一定就可以提高效率：经过设计和拆分的任务，并行执行，可以提高程序的运行效率，但也不是所有的任务都需要拆分，需要具体分析  
  
IO 操作不占用 CPU，但是 CPU 需要等待 IO 结束，于是有后续的非阻塞 IO 和异步 IO 优化  

