+++  
title = "Concurrent In Java  | 进程、线程与Java中的线程"  
subtitle = ""  
date = 2024-06-13  
description = "简要介绍进程和线程相关知识"  
short = true  
math = false  
header_img = ""  
tags=["Concurrent" ,"Java"]  
series = ["Concurrent"]  
toc = true  
+++  
## 进程与线程  
### 进程  
程序由指令和数据组成，指令要运行，数据要读写，就必须将指令加载到 CPU，数据加载到内存，同样地，在指令运行过程中可能还会用到磁盘，网络等设备  

进程是用来加载指令，管理内存，管理 IO 的，当一个程序被运行，代码从磁盘加载到内存，就开启了一个进程  
  
我们可以将进程看作是程序的一个实例  
### 线程  
一个进程可以分为多个线程  
一个线程就是一个指令流，将指令流中的一条条指令以一种顺序交给 CPU 执行，可以理解为一个程序同时需要做多件事  
  
Java 中，线程是最小的调度单位，进程是最小的资源分配单位  
在 Windows 中，进程是不活动的，只是作为线程的容器  
### 对比  
进程是相互独立的，线程存在于进程内，是进程的子集  
进程有供线程共享的资源，如内存空间  
进程间通信较为复杂：  
‌‌‌‌　　同一台计算机的进程通信称为 IPC Inter-process communication  
‌‌‌‌　　不同计算机之间的进程通信，需要通过网络  

线程通信较为简单，因为它们共享进程内存，比如可以多个线程访问一个共享变量  
线程更轻量，上下文切换成本比进程上下文切换成本低  
## 并行与并发  
单核 CPU 下，线程实际上是串行执行的，但是由于 CPU 在线程之间的切换非常快，对于人类来说是同时运行的，**微观串行，宏观并行**  
一般将**线程轮流使用 CPU** 的做法称为并发 concurrent  
  
*tips： Windows 下的时间片最小约为15ms*  
  
多核 CPU 下，每个核心都可以调度运行线程，这个时候线程是可以并行的  
  
>Rob Pike 对并发和并行的简要描述：  
>- 并发 concurrent 是同一时间应对多件事情的能力  
>- 并行 parallel 是同一时间动手做多件事情的能力  
### 异步调用  
对于调用方来说：  
‌‌‌‌　　需要等待结果返回，才能继续运行是同步  
‌‌‌‌　　不需要等待结果返回，就能继续运行是异步  
  
多线程可以让方法的执行变为异步，举个例子，Tomcat 的异步 servlet，让用户线程处理耗时比较长的操作，避免阻塞 Tomcat 的工作线程  
### 提高效率  
单核 CPU 下，多线程不能实际提高程序运行效率只是为了能够在不同的任务之间切换，不同线程轮流使用 CPU，防止部分线程饥饿  
  
多核 CPU 可以并行跑多个线程，但并不一定就可以提高效率：经过设计和拆分的任务，并行执行，可以提高程序的运行效率，但也不是所有的任务都需要拆分，需要具体分析  
  
IO 操作不占用 CPU，但是 CPU 需要等待 IO 结束，于是有后续的非阻塞 IO 和异步 IO 优化  
## Java 线程  
### 创建和运行线程  
直接使用 Thread  
Runnable 配合 Thread  
‌‌‌‌　　分离了线程和任务，更容易和线程池等配合，脱离了 Thread 继承体系，更灵活  
FutureTask 配合 Thread  
‌‌‌‌　　FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况  
线程池  
### 查看进程线程的方法  
#### Windows  
任务管理器查看进程和线程，可以结束进程  
`tasklist`  
`taskkill`  
#### Linux  
`ps -fe`查看所有进程  
`ps -fT -p <PID>`查看某个进程的所有线程  
`kill`杀死进程  
`top -H -p <PID>`查看某个进程的所有线程  
#### Java  
`jps`查看所有 Java 进程  
`jstack<PID>`查看某个 Java 进程的所有线程状态  
`jconsole`来查看某个 Java 进程中线程的运行情况  
### 线程运行的原理  
#### 栈与栈帧  
Java Virtual Machine Stacks  
每个线程启动后，虚拟机为其分配一块栈内存，每个栈由多个栈帧 Frame 组成，对应着每次方法调用时占用的内存，每个线程只能有一个活动栈帧，对应当前正在执行的方法  
#### 线程上下文切换  Thread Context Switch
可能发生上下文切换的情况：  
‌‌‌‌　　CPU 时间片用完  
‌‌‌‌　　垃圾回收  
‌‌‌‌　　有更高优先级的线程需要运行  
‌‌‌‌　　当前线程调用了 sleep yield wait join park synchronized lock 等方法  
‌‌‌‌　　……  

当 Context Switch 发生时，需要 OS 保存当前线程的状态并恢复另一个线程的状态，Java 中对应的概念是程序计数器 Program Counter Register，它的作用是记住下一条 JVM 指令的执行地址，是线程私有的  
  
状态包括：  
‌‌‌‌　　程序计数器  
‌‌‌‌　　虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等   
频繁的 Context Switch 会影响性能  
### 常见方法  
`start()`  
启动一个新线程，在新线程中运行`run`方法  
`start`只是让线程进入就绪，代码不一定立刻运行，何时运行取决于 CPU 时间片分配  
每个线程的`start`方法只能调用一次，多次调用会报一场  
  
`run()`  
新线程启动后会调用的方法  
如果在构造 Thread 对象时传递了 Runnable 参数，则在线程启动后调用 Runnable 中的`run`方法  
直接调用`run`是在主线程中执行了`run`方法，没有启动新的线程，使用`start`是启动了新的线程，间接执行`run`方法，这是这两个方法之间比较重要的区别  
  
`join(long n)`  
等待线程运行结束，最多等待 n ms  
不传入参数则等待直到线程结束  
当我们在做某一件事情前需要先等待某一个线程运行结束，就需要用到`join`方法  
  
`setPriority(int)`  
java 中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率  
但这只是对 OS 调度的建议，调度器可以忽略这个提示，最终还是取决于 OS 的实际调度  
如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，CPU 闲时，优先级几乎没有作用  
  
`getState()`  
获取线程状态  
Java 中线程状态是用 6 个 enum 表示，分别为： `NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, `TERMINATED`  
  
`interrupt()`  
打断线程  
如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，**并清除打断标记** ；如果打断的正在运行的线程，**不会清空打断状态** ；park 的线程被打断，**也不会清空打断状态**  
  
`interrupted()`  
判断当前线程是否被打断  
会清除打断标记  
  
`isInterrupted()`  
判断当前线程是否被打断  
不会清除打断标记  
  
`sleep(long n)`  
让当前执行的线程休眠 n 毫秒， 休眠时让出 CPU 的时间片给其它线程  
调用 `sleep` 会让当前线程从 `Running` 进入 `TIMED_WAITING` 状态，其他线程可以调用`interrupt`方法打断睡眠中的线程，`sleep`方法会抛出异常，睡眠结束后的线程未必会立刻得到执行  
`sleep`是 Thread 中的方法，而`wait`是 Object 中的方法，前者不需要占用锁也不会释放锁，时间到后会自动苏醒，后者会放弃所有锁且需要唤醒重新获取对象锁资源后才能继续执行，更详细的对比会在后文中进行  
  
`yield()`  
提示线程调度器，让出当前线程对 CPU 的使用  
调用`yield`方法会让当前线程从 `Running` 进入 `Runnable` 就绪状态，然后调度执行其他线程，具体实现依赖 OS 的任务调度器  
### 主线程和守护线程  
默认情况下，Java 进程需要等待所有线程都运行结束，才会结束  
守护线程是一种特殊的线程，如果其他非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束  
```java  
// 设置该线程为守护线程  
t1.setDaemon(true);  
```  
举例：  
‌‌‌‌　　垃圾回收器线程就是一种守护线程   
‌‌‌‌　　Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求  
### 线程状态  
#### OS 角度  
初始状态：语言层面创建线程，未与 OS 线程关联  
就绪状态：已经与 OS 线程关联，可由 CPU 调度执行  
运行状态：获取到了 CPU 时间片  
阻塞状态：阻塞被唤醒，进入可运行状态，如果不被唤醒，调度器就不会考虑调度它们  
终止状态：线程执行完毕，生命周期结束  
#### Java API 角度  
根据 `Thread.State` 枚举，分为六种状态  
New：线程刚被创建，还没有调用`start()`方法  
RUNNABLE：当调用了`start()`方法之后，这个状态包括了 OS 层面的“就绪状态”，“运行状态”，“阻塞状态”（比如由 BIO 导致的阻塞，对于 Java 这一层来说是透明的，Java 会认为是可运行的）  
BLOCKED，WAITING，TIMED_WAITING：都是 Java 层面对阻塞状态的的细分  
TERMINATED：当前线程运行结束  
